1.类加载机制
加载——》验证——》准备——》连接——》解析——》初始化——》使用——》卸载

2.加载：
	1.预加载：虚拟机启动时加载，加载的是JAVA_HOME/lib/rt.jar下的.class文件，这个jar包里面的内容是程序运行时常用的类，例如：
	java.lang.*、java.util.*、java、io.*等等，因此随着虚拟机一起加载。
	2.运行时加载：虚拟机在用到一个.class文件时首先会去内存中查找这个.class文件是否已经被加载，如果没有就会按照类的全限定名
	来加载这个类。加载阶段做了三件事情：
		1.获取.class文件的二进制流
		2.将类信息、静态变量、字节码、常用的这些.class文件中的内容放入方法区中
		3.在内存中生成一个代表这个.class文件的java.lang.class对象，作为方法区这个类的各种数据访问入口。一般这个class在堆里，
		不过hotSpot虚拟机比较特殊，这个class对象是放在方法区中的
		
3.验证：连接阶段的第一步，这一阶段的目的是问了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
	1.文件格式验证：.class文件的第5~8个字节砭石的是改.class文件的版本号，验证的时候会对这四个字节做一个验证，高版本的jdk能向下兼容
	低版本jdk，即使文件格式文发生任何变化，虚拟机也会拒绝执行超过其版本号的.class文件。
	2.元数据验证
	3.字节码验证
	4.符号引用验证

4.准备：准备结算时未类变量分配内存并设置其初始值得阶段，这些变量缩使用的内存都将在方法区中分配。
	1.这个时候分配内存的仅仅是类变量（被static修饰的变量），而不是实例变量，实例变量将会在对象实例化的时候随着对象德一起分配在java堆中
	2.这个阶段只会给那些被static修饰但不被final修饰的变量赋初始值，而不是实际值，例如public static int value =123；赋值之后是0
	
5.解析：解析阶段是虚拟机将常亮池内的符号引用替换为直接引用的过程
	1.符号引用：
		类和接口的全限定名、自断的名称和描述符、方法的名称和描述符
	2.直接引用：
		直接引用可以直接指向目标的指针、相对偏移量或是一个能简介定位到目标的句柄。直接引用适合虚拟机实现的内存布局先关的，同一个符号引用
		在不同的虚拟机示例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在内村中了。
		
6.初始化：初始化阶段是类加载过程的最后一步，初始化阶段是真正执行类中定义的java程序代码的过程。初始化过程是一个执行类构造器<clinit>()方法
的过程，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。初始化阶段做的事就是给static变量赋予用户制定的值以及执行静态代码块。
	注意：虚拟机会保证类的初始化在多线程环境中被正确地加锁、同步，即如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的
	<clinit>()方法，其他线程都要阻塞等待，直至这个线程初始化完成之后，因此如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个
	进程阻塞。不顾哦其他线程虽然阻塞，但是当这个类初始化完成之后，不会再进入<clinit>()方法了，因为同一个类加载器下，一个类只会被初始化一次。
	实际应用中这种阻塞往往是比较隐蔽的，要小心。
	
	java虚拟机严格规范有且只有5种场景必须立即对类进行初始化，这5种场景也称为对一个类进行主动引用：
		1.使用new关键字实例化对象、读取或者设置一个了类的静态字段（被final修饰的静态字段除外）、调用一个类的静态方法的时候
		2.使用java.lang.reflect包中的方法对类进行反射调用的时候
		3.初始化一个类，发现其父类还没有初始化的时候，需要先初始化其父类
		4.虚拟机启动的时候，虚拟机会先初始化用户制定的包含main()方法的那个类
		5.但是用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例后解析结果REF_putStatic,REF_getStatic,REF_invokeStatic的方法句柄时，
		当改方法句柄对应的类没有初始化时，需要初始化该类。（动态语言支持详情请查看）

		
		1.通过子类调用父类的静态字段，不会导致子类初始化
		2.通过数组定义来引用的类
		3.常量在编译期间间就会调入类的常量池中，本质上没有直接引用的定义变量，一次使用常量字段时不会触发类的初始化
		4.接口的初始化和类的初始化类似，区别在于5种中的第三种：当一个子类的初始化过程中需要去报其父类也必须先初始化，但接口初始化时不要求
		其父接口也进行初始化，只有在用到父接口时，才去初始化

7.类加载器：
	对于任意一个类，都需要由类加载器和这个类本身一同确定其在java中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。比较两个类是否
	相等，只有在这来那个各类是由同一个类加载器加载的前提下才有意义。否则即使这两个类来源于同一个.class文件，被同一个虚拟机加载，只要加载
	它们的类加载器不同，这两个类就不相等
	
8.类加载器模型
	从java虚拟机的角度讲，只有两种不同的类加载器：启动类加载器Bootstrap CVlassLoader 这个类加载器是由c++语言实现的，是虚拟机自身的一部分；其他类
	加载器，这些类加载器都是由java语言实现的，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。

9.CLassLoader的方法：
	loadClass(String name):改方法加载指定名称的二进制类型文件，该方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模型的实现
	loadClass(String name,boolean resolve):重载方法，resolve参数代表是否生成class对象德同事进行解析相关的操作
	findClass(String name)：获取.class文件，并且调用defineClass()方法将其转换成class对象
	resolveClass()：改方法可以使用类的Class对象创建完成时被解析











	